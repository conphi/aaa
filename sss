###### rust sock5 xor tcp ipv4 proxy ##########################
use std::io::{self, Read, Write};
use std::net::{TcpListener, TcpStream, Shutdown};
use std::thread;

const DEFAULT_PORT: &str = "1984";
const DEFAULT_KEY: &[u8] = b"aaa";

fn bridge(mut src: TcpStream, mut dst: TcpStream, key: Vec<u8>, start_idx: usize, label: &'static str) {
    let mut buf = [0u8; 16384];
    let mut idx = start_idx;
    while let Ok(n) = src.read(&mut buf) {
        if n == 0 { break; }
        for b in &mut buf[..n] {
            *b ^= key[idx % key.len()];
            idx = idx.wrapping_add(1);
        }
        if dst.write_all(&buf[..n]).is_err() { break; }
    }
    let _ = src.shutdown(Shutdown::Both);
    let _ = dst.shutdown(Shutdown::Both);
    println!("[{}] è¿æ¥å…³é—­", label);
}

fn handle_server(mut conn: TcpStream, key: Vec<u8>) -> io::Result<()> {
    let mut buf = [0u8; 1024];
    let mut up_idx: usize = 0;
    let mut down_idx: usize = 0;

    // 1. æ¡æ‰‹è®¤è¯
    let n = conn.read(&mut buf)?;
    if n == 0 { return Ok(()); }
    for b in &mut buf[..n] { *b ^= key[up_idx % key.len()]; up_idx += 1; }
    
    let mut resp = vec![0x05, 0x00];
    for b in &mut resp { *b ^= key[down_idx % key.len()]; down_idx += 1; }
    conn.write_all(&resp)?;

    // 2. è§£æè¯·æ±‚ (é‡ç‚¹ï¼šå¤„ç†åŸŸåè§£æ)
    let n = conn.read(&mut buf)?;
    if n < 4 { return Ok(()); }
    for b in &mut buf[..n] { *b ^= key[up_idx % key.len()]; up_idx += 1; }

    let target_addr = match buf[3] {
        0x01 => { // IPv4
            format!("{}.{}.{}.{}:{}", buf[4], buf[5], buf[6], buf[7], 
                    u16::from_be_bytes([buf[8], buf[9]]))
        },
        0x03 => { // åŸŸå (Domain Name)
            let len = buf[4] as usize;
            let domain = std::str::from_utf8(&buf[5..5+len]).map_err(|_| io::Error::new(io::ErrorKind::Other, "Invalid Domain"))?;
            let port = u16::from_be_bytes([buf[5+len], buf[6+len]]);
            format!("{}:{}", domain, port)
        },
        _ => return Ok(()), // æš‚ä¸æ”¯æŒ IPv6
    };

    println!("-> å°è¯•è¿æ¥ç›®æ ‡: {}", target_addr);
    let target_conn = match TcpStream::connect(&target_addr) {
        Ok(t) => t,
        Err(e) => {
            println!("! æ— æ³•è¿æ¥ç›®æ ‡: {} - {}", target_addr, e);
            return Ok(());
        }
    };

    let mut ok_resp = vec![0x05, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 0];
    for b in &mut ok_resp { *b ^= key[down_idx % key.len()]; down_idx += 1; }
    conn.write_all(&ok_resp)?;

    // 3. è½¬å‘
    let c_up = conn.try_clone()?;
    let t_down = target_conn.try_clone()?;
    let k1 = key.clone();
    let k2 = key;

    thread::spawn(move || bridge(c_up, target_conn, k1, up_idx, "Up"));
    bridge(t_down, conn, k2, down_idx, "Down");
    Ok(())
}

fn main() -> io::Result<()> {
    let args: Vec<String> = std::env::args().collect();
    let key = DEFAULT_KEY.to_vec();

    if args.len() >= 2 && args[1] == "s" {
        let port = args.get(2).map(|s| s.as_str()).unwrap_or(DEFAULT_PORT);
        let listener = TcpListener::bind(format!("0.0.0.0:{}", port))?;
        println!("ğŸš€ æœåŠ¡ç«¯å·²å¯åŠ¨ï¼Œç›‘å¬ç«¯å£ {}", port);
        for stream in listener.incoming() {
            if let Ok(s) = stream {
                let k = key.clone();
                thread::spawn(move || { let _ = handle_server(s, k); });
            }
        }
    } else if args.len() >= 3 && args[1] == "c" {
        let vps_ip = &args[2];
        let port = args.get(3).map(|s| s.as_str()).unwrap_or(DEFAULT_PORT);
        let listener = TcpListener::bind("127.0.0.1:1080")?;
        println!("ğŸš€ å®¢æˆ·ç«¯å·²å¯åŠ¨ï¼Œç›‘å¬ 1080 -> {}:{}", vps_ip, port);
        for stream in listener.incoming() {
            if let Ok(c_conn) = stream {
                if let Ok(v_conn) = TcpStream::connect(format!("{}:{}", vps_ip, port)) {
                    let k1 = key.clone();
                    let k2 = key.clone();
                    let c_up = c_conn.try_clone().unwrap();
                    let v_down = v_conn.try_clone().unwrap();
                    thread::spawn(move || bridge(c_up, v_conn, k1, 0, "Client-Up"));
                    thread::spawn(move || bridge(v_down, c_conn, k2, 0, "Client-Down"));
                }
            }
        }
    } else {
        println!("ç”¨æ³•: ./sss s [ç«¯å£] | ./sss c <VPS_IP> [ç«¯å£]");
    }
    Ok(())
}
################################################################################
rustc -O sss.rs
rustc -O -C strip=symbols sss.rs
curl -v --socks5-hostname 127.0.0.1:1080 http://google.com
######################################################################################
######################################################################################
########## zig 0.13.0 zig build-exe ssss.zig -O ReleaseSmall -fstrip
#######################################################################################
const std = @import("std");
const net = std.net;
const mem = std.mem;

const DEFAULT_KEY = "aaa";
const DEFAULT_PORT: u16 = 1984;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer _ = gpa.deinit();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        std.debug.print("ç”¨æ³•:\n  æœåŠ¡ç«¯: ./sss s [ç«¯å£]\n  å®¢æˆ·ç«¯: ./sss c <VPS_IP> [ç«¯å£]\n", .{});
        return;
    }

    const mode = args[1][0];
    const key = DEFAULT_KEY;

    if (mode == 's') {
        const port = if (args.len >= 3) try std.fmt.parseInt(u16, args[2], 10) else DEFAULT_PORT;
        const address = try net.Address.parseIp("0.0.0.0", port);
        var server = try address.listen(.{ .reuse_address = true });
        defer server.deinit();

        std.debug.print("âœ… Zig æœåŠ¡ç«¯å·²å¯åŠ¨ [ç«¯å£: {d}]\n", .{port});

        while (true) {
            const conn = try server.accept();
            _ = try std.Thread.spawn(.{}, handleServer, .{ conn, key });
        }
    } else if (mode == 'c') {
        const vps_ip = args[2];
        const vps_port = if (args.len >= 4) try std.fmt.parseInt(u16, args[3], 10) else DEFAULT_PORT;
        
        const local_addr = try net.Address.parseIp("127.0.0.1", 1080);
        var listener = try local_addr.listen(.{ .reuse_address = true });
        defer listener.deinit();

        std.debug.print("âœ… Zig å®¢æˆ·ç«¯å·²å¯åŠ¨: 127.0.0.1:1080 -> {s}:{d}\n", .{ vps_ip, vps_port });

        while (true) {
            const client_conn = try listener.accept();
            const vps_addr = try net.Address.parseIp(vps_ip, vps_port);
            const vps_conn = net.tcpConnectToAddress(vps_addr) catch {
                client_conn.stream.close();
                continue;
            };

            // å®¢æˆ·ç«¯ç›´æ¥å¼€å¯åŒå‘ç›²è½¬å‘ï¼Œæ¯ä¸ªæ–¹å‘ä¸€ä¸ªçº¿ç¨‹
            _ = try std.Thread.spawn(.{}, bridge_move, .{ client_conn.stream, vps_conn, key, 0 });
            _ = try std.Thread.spawn(.{}, bridge_move, .{ vps_conn, client_conn.stream, key, 0 });
        }
    }
}

/// æ ¸å¿ƒè½¬å‘é€»è¾‘
fn bridge(src: net.Stream, dst: net.Stream, key: []const u8, start_idx: usize) void {
    defer src.close();
    defer dst.close();
    var buf: [16384]u8 = undefined;
    var idx = start_idx;
    while (true) {
        const n = src.read(&buf) catch break;
        if (n == 0) break;
        for (buf[0..n]) |*b| {
            b.* ^= key[idx % key.len];
            idx +%= 1; // ä½¿ç”¨ Zig çš„æº¢å‡ºåŠ æ³•è¿ç®—ç¬¦
        }
        dst.writeAll(buf[0..n]) catch break;
    }
}

/// çº¿ç¨‹åŒ…è£…å‡½æ•°
fn bridge_move(src: net.Stream, dst: net.Stream, key: []const u8, idx: usize) void {
    bridge(src, dst, key, idx);
}

fn handleServer(conn: net.Server.Connection, key: []const u8) void {
    defer conn.stream.close();
    var buf: [1024]u8 = undefined;
    var up_idx: usize = 0;
    var down_idx: usize = 0;

    // 1. SOCKS5 æ¡æ‰‹
    var n = conn.stream.read(&buf) catch return;
    if (n == 0) return;
    for (buf[0..n]) |*b| { b.* ^= key[up_idx % key.len]; up_idx +%= 1; }

    var resp1 = [_]u8{ 0x05, 0x00 };
    for (&resp1) |*b| { b.* ^= key[down_idx % key.len]; down_idx +%= 1; }
    conn.stream.writeAll(&resp1) catch return;

    // 2. è§£æ CONNECT è¯·æ±‚
    n = conn.stream.read(&buf) catch return;
    if (n < 4) return;
    for (buf[0..n]) |*b| { b.* ^= key[up_idx % key.len]; up_idx +%= 1; }

    const target_stream = match_target: {
        if (buf[3] == 0x01) { // IPv4 æƒ…å†µ
            const ip4_bytes = buf[4..8].*;
            const port_bytes = buf[8..10][0..2].*; // è½¬ä¸ºå›ºå®šé•¿åº¦æ•°ç»„æŒ‡é’ˆ
            const port = mem.readInt(u16, &port_bytes, .big);
            const addr = net.Address.initIp4(ip4_bytes, port);
            break :match_target net.tcpConnectToAddress(addr) catch return;
        } else if (buf[3] == 0x03) { // åŸŸåæƒ…å†µ
            const len = buf[4];
            const domain = buf[5 .. 5 + len];
            const port_bytes = buf[5 + len .. 7 + len][0..2].*; // è½¬ä¸ºå›ºå®šé•¿åº¦æ•°ç»„æŒ‡é’ˆ
            const port = mem.readInt(u16, &port_bytes, .big);
            
            var list = net.getAddressList(std.heap.page_allocator, domain, port) catch return;
            defer list.deinit();
            break :match_target net.tcpConnectToAddress(list.addrs[0]) catch return;
        } else return;
    };
    defer target_stream.close();

    // å“åº”å®¢æˆ·ç«¯ï¼šè¿æ¥å·²å»ºç«‹
    var ok_resp = [_]u8{ 0x05, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 0 };
    for (&ok_resp) |*b| { b.* ^= key[down_idx % key.len]; down_idx +%= 1; }
    conn.stream.writeAll(&ok_resp) catch return;

    // 3. è¿›å…¥åŒå‘ XOR è½¬å‘
    const t1 = std.Thread.spawn(.{}, bridge_move, .{ conn.stream, target_stream, key, up_idx }) catch return;
    bridge(target_stream, conn.stream, key, down_idx);
    t1.join();
}
####################################################################################
